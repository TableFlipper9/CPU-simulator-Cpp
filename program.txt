# ============================================================
# Full hazard/control stress test for your MIPS-like pipeline
# Assumptions (matches your simulator):
#  - Memory is word-indexed: sw $r, 4($0) writes mem[4]
#  - Branch/jump target is an absolute instruction index in file
#  - No delay slot (taken branch/jump flushes younger instructions)
# ============================================================
# Expected final (key checks):
#   $1  = 10
#   $2  = 20
#   $3  = 30          (ALU->ALU forwarding)
#   $4  = 60          (depends on $3, another forward)
#   $5  = 60          (lw result)
#   $6  = 61          (load-use stall: lw then addi using $5)
#   mem[4]  = 60      (store-data forwarding from $4)
#   mem[5]  = 61      (store after load/use path)
#   $7  = 1234        (set after branch taken path)
#   $8  = 777         (set by JAL function)
#   $9  = 888         (set after return)
#   $10 remains 0     ($0 immutability test via writes to $0)
#   $11 = 2222        (after JR path)
# Wrong-path values must NOT appear:
#   $7 must NOT be 9999
#   $9 must NOT be 4444
# ============================================================

# --- Setup: clear memory locations we will use ---
sw   $0, 4($0)        # mem[4]=0
sw   $0, 5($0)        # mem[5]=0
sw   $0, 6($0)        # mem[6]=0

# --- Basic ALU chain to force EX forwarding ---
addi $1, $0, 10       # $1 = 10
addi $2, $0, 20       # $2 = 20
add  $3, $1, $2       # $3 = 30  (needs forward? depends timing)
add  $4, $3, $3       # $4 = 60  (ALU->ALU forward from prior)

# --- Store-data forwarding (value produced then stored) ---
sw   $4, 4($0)        # mem[4]=60 (store should get forwarded $4)

# --- Load + immediate use: load-use hazard must stall ---
lw   $5, 4($0)        # $5 = 60
addi $6, $5, 1        # $6 = 61  (MUST stall 1 cycle vs lw)

# --- Store after load/use: tests correct value & any forwarding ---
sw   $6, 5($0)        # mem[5]=61

# --- Branch depending on recently computed reg (branch compare forwarding) ---
# Make $6 == 61, set $12 = 61 via ALU right before branch
add  $12, $6, $0       # $12 = 61 (forwarding into beq compare)
beq  $12, $6, 15       # should be taken -> jump to index 15
addi $7, $0, 9999      # WRONG PATH: must be flushed
addi $7, $0, 1111      # WRONG PATH too (still flushed if taken)

# --- Branch target block (index 15) ---
addi $7, $0, 1234      # $7 = 1234 (proves branch flush worked)

# --- Branch-after-load (again): load into $13, immediately branch on it ---
sw   $0, 6($0)          # mem[6]=0
lw   $13, 6($0)         # $13=0
beq  $13, $0, 21        # taken, requires load-use stall + flush
addi $14, $0, 5555      # WRONG PATH: must be flushed
addi $14, $0, 6666      # WRONG PATH: must be flushed

# --- Target of branch-after-load (index 21) ---
addi $14, $0, 7777      # $14=7777

# --- JAL + JR (control hazard + link register correctness) ---
# Call "func" at index 31
jal  31                 # $31=return addr, jump to func
addi $9, $0, 4444       # WRONG PATH if jal flush is correct (no delay slot)

# --- Return point (should resume here after jr) ---
addi $9, $0, 888        # $9 = 888

# --- $0 immutability tests ---
addi $0, $0, 123        # should have NO effect
add  $0, $1, $2         # should have NO effect
add  $10, $0, $0        # $10 should be 0

# --- Finish marker ---
addi $11, $0, 2222      # $11 = 2222
j    34                 # jump to end (index 34)
addi $11, $0, 3333      # WRONG PATH if jump flush works

# ----------------------
# Function "func" (index 31)
# ----------------------
addi $8, $0, 777        # $8 = 777
jr   $31                # return to after jal
addi $8, $0, 999        # WRONG PATH if jr flush works

# ----------------------
# End (index 34)
# ----------------------
lw   $15, 4($0)         # $15 should read 60
lw   $16, 5($0)         # $16 should read 61
addi $17, $0, 1         # dummy end
